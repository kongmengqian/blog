# 语法

## 类（class）

### 公共`public`，私有`private`与受保护`protected`的修饰符

当成员被标记成 `private`时，它就不能在声明它的类的外部访问，包括在派生类中

属性和方法被标记成`protected`，可以在派生类中仍然可被访问

构造函数也可以被标记成 `protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承

### readonly 修饰符

你可以使用 `readonly`关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。

```js
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
```

**参数属性**

```js
class Octopus {
    readonly numberOfLegs: number = 8;
    constructor(readonly name: string) {
    }
}
```

参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 `private`限定一个参数属性会声明并初始化一个私有成员；对于 `public`和 `protected`来说也是一样。

### 静态属性 static

类的实例成员：那些仅当类被实例化的时候才会被初始化的属性。

存在于类本身上面，而不是类的实例

每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。

```js
class Grid {
    static origin = {x: 0, y: 0}; // 定义成静态属性
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x); // 访问静态属性：类名.属性名.x
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
```

## 声明

### 高级组合

有一些声明能够通过多个声明组合。 比如， `class C { }`和`interface C { }`可以同时存在并且都可以做为 `C` 类型的属性。

只要不产生冲突就是合法的。 一个普通的规则是值总是会和同名的其它值产生冲突除非它们在不同命名空间里， 类型冲突则发生在使用类型别名声明的情况下（ `type s = string`）， 命名空间永远不会发生冲突。
